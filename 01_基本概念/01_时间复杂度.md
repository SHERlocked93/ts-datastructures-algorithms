## 时间复杂度

1. 算法的速度指的并非时间，而是操作数的增速。
2. 谈论算法的速度时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加。
3. 算法的运行时间用大 O 表示法（Big O）表示。
4. `O(logn)` 比 `O(n)` 快，当需要搜索的元素越多时，前者比后者快得越多。



大 O 表示法指的是运行时间或空间的**增速**，描述的是随着问题规模的扩大，算法所使用的时间和空间增长的趋势。





比如，在按拼音排序的字典上，按音节查某个汉字的时候：

1. 从前到后挨个找： `O(n)`
2. 使用二分法查找： `O(logn)`

其实即使你没有学过算法，在这个场景也不自觉使用了二分法。首先翻开一页，如果这页的音节在你要找的音节之后，那你下一步肯定在这一页音节之前继续重复这个步骤，直到找到这个字，所以即使最近的新华字典收录了 13000 多个汉字，你也可以在 14 次之内找到这个字（对数阶），而不是一万多次。

### ❌常见的算法时间复杂度

下面是从小到大排序的常见的算法复杂度：

1. `O(1)`：常数阶，最低的时间复杂度，比如按数组下标访问数组的某个值，或者散列表/哈希表的取值。代表查找次数是一个常量，也就是无论输入数据如何变化，查找的次数都是一定的。
2. `O(logn)`：对数阶，比如二分查找，在 1024 个数据中查找一个给定数据，最坏情况就是查找 10 次。
3. `O(n)`：线性阶，比如简单查找（从头到尾的遍历），或者使用一个 for 循环进行数组求和。输入数据增加多少，耗时也就相应成线性增加多少。
4. `O(nlogn)`：线性对数阶，比如归并排序。
5. `O(n^2)`：平方阶，比如冒泡排序。
6. `O(2^n)`：指数阶，
7. `O(n!)`：阶乘阶，著名的旅行商问题就是属于此类，



问题规模较小的时候，差别不大，常数项可能会比较有较大影响，但是规模较大时，常数项基本就没什么影响，此时一般将常数系数忽略掉，通常。

时间复杂度一般优先于空间复杂度，但某些场景下可能空间复杂度比较重要，比如嵌入式

上面如果有些排序方法不太了解，以后的文章都会讲到的，跟着本系列文章一起学习吧！

## ❌平均情况、最糟情况、最佳情况



![时间复杂度变化趋势](https://cdn.jsdelivr.net/gh/SHERlocked93/pic@master/uPic/HxPQLt.jpg)

> 上图引用自 [Big O Cheat Sheet](http://bigocheatsheet.com/).



数据规模的概念

，如果要想在1s之内解决问题

`O(n^2)` 的算法可以处理大约 `10^4` 级别的数据

`O(n)` 的算法可以处理大约 `10^8` 级别的数据

`O(nlogn)`的算法可以处理大约 `10^7` 级别的数据



---
网上的帖子大多深浅不一，甚至有些前后矛盾，在下的文章都是学习过程中的总结，如果发现错误，欢迎留言指出，如果本文帮助到了你，别忘了点赞支持一下哦，你的点赞是我更新的最大动力！（收藏不点赞，都是耍流氓 🤣）~


> 参考文档：
>
> 1. [算法的时间与空间复杂度（一看就懂）](https://zhuanlan.zhihu.com/p/50479555)

PS：本文收录在在下的博客 [Github - SHERlocked93/blog](https://github.com/SHERlocked93/blog) 的算法系列文章中，欢迎大家关注我的公众号 `前端下午茶`，直接搜索即可添加或者点[这里](https://cdn.jsdelivr.net/gh/SHERlocked93/pic@master/uPic/TJt4p2-19-56-21.jpg)添加，持续为大家推送前端以及前端周边相关优质技术文，共同进步，一起加油~

另外可以加入「前端下午茶交流群」微信群，微信搜索  `qianyu443033099` 加我好友，备注**加群**，我拉你入群～

